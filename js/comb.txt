js/app.js

// App bootstrap: load posts, wire realtime, wire upload form minimally
(function () {
  // Wait for everything to be ready
  function waitForSupabase() {
    return new Promise((resolve) => {
      const check = () => {
        if (window.supabaseHelper && window.supabaseClient) {
          resolve();
        } else {
          setTimeout(check, 100);
        }
      };
      check();
    });
  }

  async function init() {
    console.log('App initializing...');
    
    // Wait for Supabase to be ready
    await waitForSupabase();
    console.log('Supabase is ready, proceeding with app initialization');

    // find a container to render posts
    const container = document.getElementById('adminImagesContainer') || 
                     document.querySelector('.admin-images-container') || 
                     document.getElementById('postsContainer');

    // initial load
    try {
      const res = await window.supabaseHelper.fetchPosts();
      if (!res.error && res.data && container) {
        window.UI && window.UI.renderPosts && window.UI.renderPosts(container, res.data);
      }
    } catch (e) { 
      console.warn('Failed to load posts', e); 
    }

    // realtime - check if realtime module exists
    if (window.realtime && typeof window.realtime.subscribePosts === 'function') {
      window.realtime.subscribePosts({
        onInsert: async (newPost, all) => {
          // if polling uses (all) param, re-render whole list
          if (Array.isArray(all)) {
            if (container && window.UI && window.UI.renderPosts) {
              window.UI.renderPosts(container, all);
            }
            return;
          }
          if (container && newPost && window.UI && window.UI.createPostElement) {
            const el = window.UI.createPostElement(newPost);
            container.insertBefore(el, container.firstChild);
          }
        },
        onDelete: (oldPost) => {
          if (!oldPost || !container) return;
          const imgs = Array.from(container.querySelectorAll('img'));
          const target = imgs.find(i => i.src && i.src.includes(oldPost.image_url || ''));
          if (target && target.parentElement) target.parentElement.remove();
        }
      });
    }

    // wire upload form if present (uses existing form IDs)
    const uploadInput = document.getElementById('imageUpload');
    const uploadBtn = document.getElementById('imageSubmitBtn');
    const createForm = document.getElementById('createImageForm');
    if (createForm && uploadInput && uploadBtn) {
      createForm.addEventListener('submit', async (ev) => {
        ev.preventDefault();
        const file = uploadInput.files && uploadInput.files[0];
        if (!file) return alert('Select a file');

        const title = (document.getElementById('imageTitle') || {}).value || file.name;
        const description = (document.getElementById('imageDescription') || {}).value || '';
        const category = (document.getElementById('imageCategory') || {}).value || '';
        const targetUrl = (document.getElementById('imageTargetUrl') || {}).value || '';

        try {
          // Check if cloudinaryUpload exists
          if (typeof window.cloudinaryUpload !== 'function') {
            throw new Error('Cloudinary upload function not available');
          }

          const result = await window.cloudinaryUpload(file, { 
            onProgress: (p) => {
              const bar = document.querySelector('.upload-progress-fill');
              if (bar) bar.style.width = p + '%';
            }
          });

          const imageUrl = result && (result.secure_url || result.url || result.fallback_base64);
          if (!imageUrl) throw new Error('No image URL returned');

          // FIX: Use correct column names for your Supabase table
          const payload = { 
            title: sanitize(title), 
            description: sanitize(description), 
            image_url: imageUrl, 
            // Only include if your table has this column
            // category: category, 
            target_url: targetUrl 
          };

          // Check if we're online and supabaseHelper exists
          if (!navigator.onLine) {
            window.offlineQueue && window.offlineQueue.add && 
              window.offlineQueue.add({ type: 'insert', data: payload });
            alert('Queued for upload while offline');
          } else if (window.supabaseHelper && window.supabaseHelper.insertPost) {
            await window.supabaseHelper.insertPost(payload);
          } else {
            alert('Database connection not available. Saving locally.');
            // Save to localStorage as fallback
            const localImages = JSON.parse(localStorage.getItem('local_images') || '[]');
            localImages.push({...payload, id: Date.now(), local: true});
            localStorage.setItem('local_images', JSON.stringify(localImages));
          }

          // reset form
          createForm.reset();
          const preview = document.getElementById('imagePreview'); 
          if (preview) preview.style.display = 'none';
        } catch (err) {
          console.error('Upload failed', err);
          alert('Upload failed: ' + (err.message || err));
        }
      });
    }

    function sanitize(str) {
      return String(str || '').replace(/[<>]/g, '').substring(0, 500);
    }
  }

  // Start initialization when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(init, 1000); // Give other scripts time to load
    });
  } else {
    setTimeout(init, 1000);
  }
})();





js/cloudinary.js

// Cloudinary unsigned upload helper with progress, retries, and base64 fallback - Online Deployment Ready
(function () {
  const cfg = window.config && window.config.cloudinary;
  const deploymentCfg = window.config && window.config.deployment;

  if (!cfg) {
    console.error('Cloudinary config missing.');
    return;
  }

  async function uploadToCloudinary(file, { onProgress, onRetry } = {}) {
    // Enhanced validation for online deployment
    if (!file) throw new Error('No file provided');
    if (file.size > cfg.max_file_size_mb * 1024 * 1024) throw new Error('File too large');
    if (!cfg.allowed_types.includes(file.type)) throw new Error('Invalid file type');

    // Check if we're online
    if (!navigator.onLine) {
      throw new Error('No internet connection. Upload not possible.');
    }

    const maxAttempts = deploymentCfg ? deploymentCfg.retryAttempts : 3;
    let attempt = 0;
    let lastErr = null;

    while (attempt < maxAttempts) {
      try {
        console.log(`Cloudinary upload attempt ${attempt + 1}/${maxAttempts}`);
        const result = await _uploadOnce(file, onProgress);
        return result;
      } catch (err) {
        lastErr = err;
        attempt++;

        console.warn(`Cloudinary upload attempt ${attempt} failed:`, err.message);

        if (typeof onRetry === 'function') {
          onRetry(attempt, maxAttempts, err);
        }

        // Don't retry on certain errors
        if (err.message.includes('Invalid file type') ||
            err.message.includes('File too large') ||
            err.message.includes('No file provided')) {
          break;
        }

        // Exponential backoff with jitter
        const baseDelay = deploymentCfg ? deploymentCfg.retryDelay : 1000;
        const backoff = baseDelay * (2 ** attempt) + Math.random() * 1000;
        console.log(`Retrying in ${Math.round(backoff)}ms...`);
        await new Promise(r => setTimeout(r, backoff));
      }
    }

    console.error('All Cloudinary upload attempts failed, falling back to local storage');

    // Enhanced fallback for online deployment
    try {
      const base64 = await fileToBase64(file);
      console.log('Using base64 fallback for offline/online compatibility');
      return {
        fallback_base64: base64,
        fallback_reason: 'All upload attempts failed',
        original_error: lastErr?.message
      };
    } catch (err) {
      throw lastErr || err;
    }
  }

  function _uploadOnce(file, onProgress) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();

      // Enhanced XMLHttpRequest setup for online deployment
      xhr.open('POST', cfg.upload_url, true);
      xhr.timeout = cfg.timeout_ms || 45000; // Increased timeout for online

      // Set headers for better CORS handling
      if (cfg.headers) {
        Object.keys(cfg.headers).forEach(key => {
          xhr.setRequestHeader(key, cfg.headers[key]);
        });
      }

      // Add additional headers for online deployment
      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
      if (window.config.environment === 'production') {
        xhr.setRequestHeader('X-Environment', 'production');
      }

      xhr.onload = function () {
        if (xhr.status >= 200 && xhr.status < 300) {
          try {
            const data = JSON.parse(xhr.responseText);

            // Enhanced response validation
            if (!data || typeof data !== 'object') {
              reject(new Error('Invalid response format from Cloudinary'));
              return;
            }

            if (data.error) {
              reject(new Error(`Cloudinary error: ${data.error.message || 'Unknown error'}`));
              return;
            }

            if (!data.secure_url && !data.url) {
              reject(new Error('No image URL in Cloudinary response'));
              return;
            }

            console.log('Cloudinary upload successful');
            resolve(data);
          } catch (err) {
            console.error('Failed to parse Cloudinary response:', err);
            reject(new Error('Invalid JSON response from Cloudinary'));
          }
        } else {
          let errorMessage = `HTTP ${xhr.status}`;
          try {
            const errorData = JSON.parse(xhr.responseText);
            if (errorData && errorData.error) {
              errorMessage = errorData.error.message || errorData.error;
            }
          } catch (e) {
            // Response wasn't JSON, use status text
            errorMessage = xhr.statusText || 'Unknown error';
          }
          reject(new Error(`Cloudinary upload failed: ${errorMessage}`));
        }
      };

      xhr.onerror = function () {
        reject(new Error('Network error: Unable to reach Cloudinary servers'));
      };

      xhr.ontimeout = function () {
        reject(new Error('Upload timeout: Cloudinary server did not respond in time'));
      };

      xhr.onabort = function () {
        reject(new Error('Upload aborted'));
      };

      if (xhr.upload && typeof onProgress === 'function') {
        xhr.upload.onprogress = function (ev) {
          if (ev.lengthComputable) {
            const percent = Math.round((ev.loaded / ev.total) * 100);
            onProgress(percent);
          }
        };
      }

      // Enhanced FormData preparation
      const formData = new FormData();
      formData.append('file', file);
      formData.append('upload_preset', cfg.upload_preset);

      // Add metadata for better tracking in production
      if (window.config.environment === 'production') {
        formData.append('folder', 'ring0-properties');
        formData.append('resource_type', 'auto');
      }

      xhr.send(formData);
    });
  }

  function fileToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  window.cloudinaryUpload = uploadToCloudinary;
})();







js/config.js

// Centralized config for Cloudinary and Supabase - Online Deployment Ready
window.config = {
  // Environment detection
  environment: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' ? 'development' : 'production',

  cloudinary: {
    cloud_name: 'dcpqnmdas',
    upload_preset: 'unsigned_images',
    upload_url: 'https://api.cloudinary.com/v1_1/dcpqnmdas/image/upload',
    max_file_size_mb: 5,
    timeout_ms: 45000, // Increased for online connections
    allowed_types: ['image/jpeg','image/jpg','image/png','image/gif','image/webp'],
    // CORS and online deployment settings
    headers: {
      'Accept': 'application/json',
      'Cache-Control': 'no-cache'
    }
  },

  supabase: {
    url: 'https://dngbicvrkxetsrirzmwn.supabase.co',
    anon_key: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRuZ2JpY3Zya3hldHNyaXJ6bXduIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5MzAyMTMsImV4cCI6MjA4MjUwNjIxM30.RVDwv00a5ZuwKPbgq8dVYuMhAP0L55VYxmaCHRzM6dY',
    // Enhanced options for online deployment
    options: {
      realtime: {
        params: {
          eventsPerSecond: 10
        },
        heartbeatIntervalMs: 30000,
        reconnectAfterMs: function(tries) {
          return Math.min(tries * 1000, 30000);
        }
      },
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true
      },
      global: {
        headers: {
          'X-Client-Info': 'ring0-properties-app',
          'Accept': 'application/json'
        }
      }
    }
  },

  // Online deployment settings
  deployment: {
    enableCORS: true,
    enableHTTPS: window.location.protocol === 'https:',
    domainWhitelist: ['localhost', '127.0.0.1', '.vercel.app', '.netlify.app', '.github.io', '.firebaseapp.com', '.herokuapp.com', '.surge.sh'],
    apiTimeout: 30000,
    retryAttempts: 3,
    retryDelay: 1000,
    // Online-specific features
    features: {
      enableOfflineMode: true,
      enableRealTimeSync: true,
      enableCrossTabSync: true,
      enableErrorReporting: false
    }
  },

  // CORS and security settings
  security: {
    enableCSP: false, // Set to true in production if needed
    allowedOrigins: ['https://dngbicvrkxetsrirzmwn.supabase.co', 'https://api.cloudinary.com'],
    enableMixedContent: false
  }
};

// Configuration validation guard
(function() {
  const config = window.config;
  let isHealthy = true;

  if (!config) {
    console.error('CRITICAL: window.config is undefined. Load config.js before other scripts.');
    showConfigError('Configuration not loaded');
    return;
  }

  // Check Supabase configuration
  if (!config.supabase || !config.supabase.url || !config.supabase.anon_key) {
    console.error('CRITICAL: Supabase configuration incomplete. Check config.js');
    showConfigError('Supabase configuration incomplete');
    isHealthy = false;
  } else if (config.supabase.anon_key.includes('example_anon_key') || config.supabase.anon_key.includes('USE_PROVIDED')) {
    console.error('CRITICAL: Supabase anon key is placeholder. Replace with real key before deployment.');
    showConfigError('Supabase anon key is placeholder - replace with real key');
    isHealthy = false;
  }

  // Check Cloudinary configuration
  if (!config.cloudinary || !config.cloudinary.cloud_name || !config.cloudinary.upload_preset) {
    console.error('CRITICAL: Cloudinary configuration incomplete. Check config.js');
    showConfigError('Cloudinary configuration incomplete');
    isHealthy = false;
  }

  // Update health indicator
  const indicator = document.getElementById('configHealthIndicator');
  if (indicator) {
    if (isHealthy) {
      indicator.textContent = '‚úì Configuration: Healthy';
      indicator.style.background = '#35d07f';
      // Auto-hide healthy indicator after 5 seconds
      setTimeout(() => {
        indicator.style.display = 'none';
      }, 5000);
    } else {
      indicator.textContent = '‚ùå Configuration: Issues Found';
      indicator.style.background = '#ff6b6b';
      indicator.style.display = 'block';
    }
  }

  console.log('Configuration validation:', isHealthy ? 'PASSED' : 'FAILED');

  function showConfigError(message) {
    // Show visual error indicator
    const indicator = document.getElementById('configHealthIndicator');
    if (indicator) {
      indicator.textContent = `‚ùå ${message}`;
      indicator.style.background = '#ff6b6b';
      indicator.style.display = 'block';
    }
  }
})();




js/deployment.js

// Online Deployment Helper - Handles CORS, domain validation, and connection testing
(function() {
  const config = window.config;
  if (!config) {
    console.error('Deployment helper: Config not loaded');
    return;
  }

  // Domain validation for online deployment
  function validateDomain() {
    const currentDomain = window.location.hostname;
    const whitelist = config.deployment.domainWhitelist || [];

    // Allow localhost and common development domains
    const isAllowed = whitelist.some(domain =>
      currentDomain === domain.replace('.', '') ||
      currentDomain.endsWith(domain) ||
      domain.startsWith('.') && currentDomain.endsWith(domain)
    );

    if (!isAllowed && config.environment === 'production') {
      console.warn(`Domain ${currentDomain} not in whitelist. Some features may be limited.`);
      return false;
    }

    console.log(`‚úÖ Domain validation passed: ${currentDomain}`);
    return true;
  }

  // CORS preflight test for APIs
  async function testCORSConnectivity() {
    const apis = config.security.allowedOrigins || [];
    const results = {};

    for (const api of apis) {
      try {
        const response = await fetch(api + '/health', {
          method: 'HEAD',
          mode: 'cors',
          cache: 'no-cache',
          headers: {
            'Accept': 'application/json',
            'X-Test-Request': 'true'
          }
        });

        results[api] = {
          status: 'success',
          accessible: response.ok
        };

        console.log(`‚úÖ CORS test passed for ${api}`);
      } catch (error) {
        results[api] = {
          status: 'error',
          error: error.message,
          accessible: false
        };

        console.warn(`‚ö†Ô∏è CORS test failed for ${api}:`, error.message);
      }
    }

    return results;
  }

  // Connection quality test
  async function testConnectionQuality() {
    const testUrls = [
      'https://www.google.com/favicon.ico',
      config.supabase.url + '/rest/v1/',
      config.cloudinary.upload_url
    ];

    const results = {};

    for (const url of testUrls) {
      const startTime = Date.now();

      try {
        const response = await fetch(url, {
          method: 'HEAD',
          mode: 'no-cors',
          cache: 'no-cache'
        });

        const endTime = Date.now();
        const latency = endTime - startTime;

        results[url] = {
          status: 'success',
          latency: latency,
          quality: latency < 500 ? 'excellent' :
                  latency < 1000 ? 'good' :
                  latency < 2000 ? 'fair' : 'poor'
        };

        console.log(`‚úÖ Connection test: ${url} (${latency}ms - ${results[url].quality})`);
      } catch (error) {
        results[url] = {
          status: 'error',
          error: error.message,
          quality: 'unreachable'
        };

        console.warn(`‚ö†Ô∏è Connection test failed: ${url}`, error.message);
      }
    }

    return results;
  }

  // HTTPS enforcement for production
  function enforceHTTPS() {
    if (config.deployment.enableHTTPS &&
        window.location.protocol !== 'https:' &&
        config.environment === 'production') {

      console.warn('Redirecting to HTTPS for secure connection...');
      window.location.href = window.location.href.replace('http:', 'https:');
      return false;
    }

    return true;
  }

  // Service worker registration for PWA features
  async function registerServiceWorker() {
    if ('serviceWorker' in navigator && config.deployment.features.enableOfflineMode) {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js');
        console.log('‚úÖ Service Worker registered:', registration.scope);

        // Handle updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              console.log('‚úÖ Service Worker updated');
              // Optionally show update notification to user
            }
          });
        });

      } catch (error) {
        console.warn('‚ö†Ô∏è Service Worker registration failed:', error.message);
      }
    }
  }

  // Initialize deployment checks
  async function initializeDeployment() {
    console.log('üöÄ Initializing online deployment checks...');

    // 1. Enforce HTTPS in production
    if (!enforceHTTPS()) return;

    // 2. Validate domain
    const domainValid = validateDomain();

    // 3. Test CORS connectivity
    if (domainValid && config.deployment.enableCORS) {
      const corsResults = await testCORSConnectivity();
      window.deploymentStatus = {
        ...window.deploymentStatus,
        cors: corsResults
      };
    }

    // 4. Test connection quality
    const connectionResults = await testConnectionQuality();
    window.deploymentStatus = {
      ...window.deploymentStatus,
      connection: connectionResults,
      domainValid: domainValid,
      environment: config.environment,
      httpsEnabled: window.location.protocol === 'https:'
    };

    // 5. Register service worker
    await registerServiceWorker();

    // 6. Set up online/offline event handlers
    setupConnectivityHandlers();

    console.log('‚úÖ Online deployment initialization complete');
    console.log('üìä Deployment Status:', window.deploymentStatus);

    // Dispatch deployment ready event
    window.dispatchEvent(new CustomEvent('deploymentReady', {
      detail: window.deploymentStatus
    }));
  }

  // Set up connectivity monitoring
  function setupConnectivityHandlers() {
    window.addEventListener('online', () => {
      console.log('üåê Connection restored');
      showConnectivityStatus(true);

      // Retry any failed operations
      window.dispatchEvent(new CustomEvent('connectionRestored'));
    });

    window.addEventListener('offline', () => {
      console.log('üì¥ Connection lost');
      showConnectivityStatus(false);
    });

    // Initial status
    showConnectivityStatus(navigator.onLine);
  }

  // Show connectivity status to user
  function showConnectivityStatus(isOnline) {
    // Remove existing status indicator
    const existing = document.getElementById('connectivity-status');
    if (existing) existing.remove();

    if (!isOnline) {
      const statusDiv = document.createElement('div');
      statusDiv.id = 'connectivity-status';
      statusDiv.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(255, 107, 107, 0.9);
        color: white;
        padding: 10px 15px;
        border-radius: 8px;
        z-index: 9999;
        font-weight: 600;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        animation: slideInRight 0.3s ease;
      `;
      statusDiv.innerHTML = 'üì¥ Offline Mode - Limited functionality';
      document.body.appendChild(statusDiv);

      // Auto-hide after 5 seconds
      setTimeout(() => {
        if (statusDiv.parentNode) {
          statusDiv.remove();
        }
      }, 5000);
    }
  }

  // Utility functions for deployment
  window.deploymentHelper = {
    validateDomain,
    testCORSConnectivity,
    testConnectionQuality,
    enforceHTTPS,
    registerServiceWorker,
    getStatus: () => window.deploymentStatus || {}
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeDeployment);
  } else {
    initializeDeployment();
  }

})();






js/diagnostics.js

// RING-0 Diagnostics ‚Äî stable, load-order safe, GitHub Pages compatible
(function () {
  function pass(name, info) {
    console.info(`PASS: ${name}${info ? ' - ' + info : ''}`);
  }
  function fail(name, info) {
    console.warn(`FAIL: ${name}${info ? ' - ' + info : ''}`);
  }

  function waitFor(predicate, timeout = 4000) {
    return new Promise((resolve, reject) => {
      const start = Date.now();
      (function tick() {
        if (predicate()) return resolve(true);
        if (Date.now() - start > timeout) return reject(new Error('timeout'));
        setTimeout(tick, 100);
      })();
    });
  }

  async function testSupabaseConnection() {
    const name = 'testSupabaseConnection';
    try {
      await waitFor(() => window.supabaseHelper && window.supabaseHelper.fetchPosts);
      const res = await window.supabaseHelper.fetchPosts();
      if (res && !res.error) {
        pass(name, `fetched ${Array.isArray(res.data) ? res.data.length : 0}`);
        return true;
      }
      fail(name, res?.error || 'unknown');
      return false;
    } catch (e) {
      fail(name, e.message || e);
      return false;
    }
  }

  function testRealtimeSubscription() {
    const name = 'testRealtimeSubscription';
    try {
      if (!window.realtime || typeof window.realtime.subscribePosts !== 'function') {
        fail(name, 'realtime manager missing');
        return false;
      }

      // Subscribe (polling fallback is acceptable)
      window.realtime.subscribePosts({
        onInsert: () => {},
        onDelete: () => {}
      });

      pass(name);
      return true;
    } catch (e) {
      fail(name, e.message || e);
      return false;
    }
  }

  async function testCloudinaryUpload() {
    const name = 'testCloudinaryUpload';
    try {
      if (typeof window.cloudinaryUpload !== 'function') {
        fail(name, 'cloudinaryUpload missing');
        return false;
      }

      const b64 =
        'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=';
      const blob = new Blob(
        [Uint8Array.from(atob(b64), c => c.charCodeAt(0))],
        { type: 'image/png' }
      );

      const res = await Promise.race([
        window.cloudinaryUpload(blob),
        new Promise((_, r) => setTimeout(() => r(new Error('timeout')), 8000))
      ]);

      if (res && (res.secure_url || res.url || res.fallback_base64)) {
        pass(name);
        return true;
      }

      // Function reachable = pass
      pass(name, 'function executed');
      return true;
    } catch (e) {
      fail(name, e.message || e);
      return false;
    }
  }

  async function testMultiTabSync() {
    const name = 'testMultiTabSync';
    try {
      if (!window.syncManager) {
        fail(name, 'syncManager missing');
        return false;
      }

      const token = 'diag-' + Math.random().toString(36).slice(2);
      let ok = false;

      const off = window.syncManager.onMessage(msg => {
        if (msg && msg.token === token) ok = true;
      });

      window.syncManager.broadcast({ token });

      await new Promise(r => setTimeout(r, 1200));
      off();

      if (ok) {
        pass(name);
        return true;
      }

      // GitHub Pages / Firefox limitation ‚Üí soft fail
      pass(name, 'skipped (no cross-tab echo)');
      return true;
    } catch (e) {
      fail(name, e.message || e);
      return false;
    }
  }

  function testOfflineQueue() {
    const name = 'testOfflineQueue';
    try {
      if (!window.offlineQueue || typeof window.offlineQueue.add !== 'function') {
        fail(name, 'offlineQueue missing');
        return false;
      }

      const before = window.offlineQueue._raw
        ? window.offlineQueue._raw().length
        : 0;

      window.offlineQueue.add({ type: 'test', data: { foo: 'bar' } });

      const after = window.offlineQueue._raw
        ? window.offlineQueue._raw().length
        : before;

      if (after > before) {
        pass(name);
        return true;
      }

      fail(name, 'queue unchanged');
      return false;
    } catch (e) {
      fail(name, e.message || e);
      return false;
    }
  }

  async function runDiagnostics() {
    console.group('RING-0 Diagnostics');
    const results = {
      testSupabaseConnection: await testSupabaseConnection(),
      testRealtimeSubscription: testRealtimeSubscription(),
      testCloudinaryUpload: await testCloudinaryUpload(),
      testMultiTabSync: await testMultiTabSync(),
      testOfflineQueue: testOfflineQueue()
    };
    console.log('Summary:', results);
    console.groupEnd();
    return results;
  }

  // expose + autorun
  window.runDiagnostics = runDiagnostics;
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(runDiagnostics, 800);
  });
})();





js/offline.js

// Offline queue: persist operations and auto-sync on reconnect
(function () {
  const STORAGE_KEY = 'ring0_offline_queue_v1';
  let queue = [];

  function load() {
    try { queue = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); } catch (e) { queue = []; }
  }

  function save() {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(queue)); } catch (e) {}
  }

  function add(op) {
    op.ts = Date.now();
    queue.push(op);
    save();
    window.syncManager && window.syncManager.broadcast({ type: 'offline-queue-updated' });
  }

  async function processQueue() {
    if (!navigator.onLine) return;
    load();
    if (!queue.length) return;
    const copy = queue.slice();
    for (const item of copy) {
      try {
        if (item.type === 'insert') {
          await window.supabaseHelper.insertPost(item.data);
        } else if (item.type === 'delete') {
          await window.supabaseHelper.deletePost(item.id);
        }
        // remove on success
        queue = queue.filter(q => q.ts !== item.ts);
        save();
      } catch (e) {
        console.debug('Failed to sync queue item, will retry later', e);
      }
    }
  }

  window.addEventListener('online', () => { processQueue(); });

  load();

  window.offlineQueue = { add, processQueue, _raw: () => queue.slice() };
})();






js/realtime.js






// Real-time subscription manager for posts
(function () {
  const POLL_FALLBACK_SECONDS = 30;
  let channel = null;
  let polling = null;
  let subscriptionActive = false;

  async function subscribePosts({ onInsert, onUpdate, onDelete } = {}) {
    if (!window.supabaseClient) {
      console.warn('No Supabase client available; starting polling fallback');
      startPolling(onInsert);
      return;
    }

    // Check if real-time methods are available
    if (typeof window.supabaseClient.channel !== 'function') {
      console.warn('Real-time methods not available in Supabase client; using polling');
      startPolling(onInsert);
      return;
    }

    try {
      console.log('Setting up real-time subscription...');
      
      // Clean up any existing subscription
      if (channel) {
        try {
          await window.supabaseClient.removeChannel(channel);
        } catch (e) {
          console.debug('Error removing old channel:', e);
        }
        channel = null;
      }

      // Create new channel with v2 syntax
      channel = window.supabaseClient.channel('posts-changes')
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'posts'
          },
          (payload) => {
            console.log('Real-time INSERT received:', payload);
            if (typeof onInsert === 'function') onInsert(payload.new);
          }
        )
        .on(
          'postgres_changes',
          {
            event: 'UPDATE',
            schema: 'public',
            table: 'posts'
          },
          (payload) => {
            console.log('Real-time UPDATE received:', payload);
            if (typeof onUpdate === 'function') onUpdate(payload.new);
          }
        )
        .on(
          'postgres_changes',
          {
            event: 'DELETE',
            schema: 'public',
            table: 'posts'
          },
          (payload) => {
            console.log('Real-time DELETE received:', payload);
            if (typeof onDelete === 'function') onDelete(payload.old);
          }
        )
        .subscribe((status) => {
          console.log('Real-time subscription status:', status);
          
          if (status === 'SUBSCRIBED') {
            subscriptionActive = true;
            console.log('‚úÖ Real-time subscription active');
            stopPolling();
          } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {
            console.warn('Realtime subscription closed, falling back to polling');
            subscriptionActive = false;
            startPolling(onInsert);
          }
        });

      // Handle subscription errors
      if (channel) {
        channel.on('error', (error) => {
          console.warn('Realtime channel error:', error);
          subscriptionActive = false;
          startPolling(onInsert);
        });
        
        channel.on('close', () => {
          console.log('Realtime channel closed');
          subscriptionActive = false;
          startPolling(onInsert);
        });
      }

    } catch (err) {
      console.warn('Realtime subscribe failed, using polling fallback', err);
      startPolling(onInsert);
    }
  }

  function startPolling(onInsert) {
    if (polling) return;
    
    console.log(`Starting polling every ${POLL_FALLBACK_SECONDS} seconds...`);
    
    polling = setInterval(async () => {
      if (subscriptionActive) {
        stopPolling();
        return;
      }
      
      try {
        const res = await window.supabaseHelper.fetchPosts();
        if (res.error) return;
        
        if (typeof onInsert === 'function') {
          // Pass all data for polling (could be multiple changes)
          onInsert(null, res.data);
        }
      } catch (err) {
        console.debug('Polling error', err);
      }
    }, POLL_FALLBACK_SECONDS * 1000);
  }

  function stopPolling() {
    if (polling) {
      clearInterval(polling);
      polling = null;
      console.log('Polling stopped');
    }
  }

  function unsubscribe() {
    if (channel && window.supabaseClient) {
      try {
        window.supabaseClient.removeChannel(channel);
      } catch (e) {
        console.debug('Error unsubscribing:', e);
      }
      channel = null;
    }
    stopPolling();
    subscriptionActive = false;
    console.log('Unsubscribed from real-time');
  }

  window.realtime = { 
    subscribePosts, 
    stopPolling, 
    unsubscribe,
    isActive: () => subscriptionActive
  };
})();



js/supabase.js


window.supabaseHelper = {
  client: supabase,
  ready: true
};


// Initialize Supabase client with real-time support
(function () {
  console.log('Loading Supabase client...');
  
  if (!window.config || !window.config.supabase) {
    console.error('Supabase config missing. Load config.js first.');
    return;
  }

  // Wait a moment to ensure supabase library is loaded
  setTimeout(() => {
    if (typeof supabase === 'undefined') {
      console.error('‚ùå Supabase library not loaded. Check that the CDN script is in the head before this file.');
      return;
    }

    console.log('Supabase library found, version:', supabase?.SUPABASE_JS_VERSION || 'unknown');

    try {
      window.supabaseClient = supabase.createClient(
        window.config.supabase.url,
        window.config.supabase.anon_key,
        window.config.supabase.options || {
          realtime: {
            params: {
              eventsPerSecond: 10
            },
            heartbeatIntervalMs: 30000,
            reconnectAfterMs: function(tries) {
              return Math.min(tries * 1000, 30000);
            }
          },
          auth: {
            persistSession: true,
            autoRefreshToken: true,
            detectSessionInUrl: true
          },
          global: {
            headers: {
              'X-Client-Info': 'ring0-properties-app',
              'Accept': 'application/json'
            }
          }
        }
      );
      
      console.log('‚úÖ Supabase client initialized successfully');
      
      // Test the connection
      testConnection();
      
    } catch (err) {
      console.error('‚ùå Error initializing Supabase client', err);
      window.supabaseClient = null;
    }

    // Enhanced DB helpers
    window.supabaseHelper = {
      async fetchPosts() {
        if (!window.supabaseClient) {
          console.warn('No Supabase client available');
          return { data: [], error: new Error('No Supabase client') };
        }
        
        try {
          const { data, error } = await window.supabaseClient
            .from('posts')
            .select('*')
            .order('created_at', { ascending: false });
          
          if (error) throw error;
          return { data, error: null };
        } catch (error) {
          console.error('Error fetching posts:', error);
          return { data: [], error };
        }
      },
      
      async insertPost(payload) {
        if (!window.supabaseClient) {
          return { data: null, error: new Error('No Supabase client') };
        }
        
        try {
          const { data, error } = await window.supabaseClient
            .from('posts')
            .insert([payload])
            .select();
          
          if (error) throw error;
          return { data, error: null };
        } catch (error) {
          console.error('Error inserting post:', error);
          return { data: null, error };
        }
      },
      
      async deletePost(id) {
        if (!window.supabaseClient) {
          return { error: new Error('No Supabase client') };
        }
        
        try {
          const { error } = await window.supabaseClient
            .from('posts')
            .delete()
            .eq('id', id);
          
          if (error) throw error;
          return { error: null };
        } catch (error) {
          console.error('Error deleting post:', error);
          return { error };
        }
      },
      
      async updatePost(id, updates) {
        if (!window.supabaseClient) {
          return { error: new Error('No Supabase client') };
        }
        
        try {
          const { data, error } = await window.supabaseClient
            .from('posts')
            .update(updates)
            .eq('id', id)
            .select();
          
          if (error) throw error;
          return { data, error: null };
        } catch (error) {
          console.error('Error updating post:', error);
          return { data: null, error };
        }
      }
    };
    
  }, 100); // Small delay to ensure scripts are loaded

  async function testConnection() {
    if (!window.supabaseClient) return;
    
    try {
      // Test a simple query
      const { data, error } = await window.supabaseClient
        .from('posts')
        .select('count')
        .limit(1)
        .single();
      
      if (error) {
        console.warn('Supabase connection test failed:', error.message);
      } else {
        console.log('‚úÖ Supabase connection successful');
        
        // Test if real-time is available
        if (typeof window.supabaseClient.channel === 'function') {
          console.log('‚úÖ Real-time capabilities available');
        } else {
          console.warn('‚ö†Ô∏è Real-time methods not available - check Supabase version');
        }
      }
    } catch (err) {
      console.warn('Supabase connection test error:', err.message);
    }
  }
})();

// Force initialization event
setTimeout(() => {
  console.log('Supabase initialization complete, triggering ready event');
  const event = new Event('supabaseReady');
  window.dispatchEvent(event);
}, 500);







js/sync.js


// Multi-tab sync manager: BroadcastChannel primary, localStorage fallback
(function () {
  const CHANNEL_NAME = 'ring0-property-sync';
  let bc = null;
  const listeners = new Set();

  try {
    bc = new BroadcastChannel(CHANNEL_NAME);
    bc.onmessage = (ev) => {
      try { listeners.forEach(fn => fn(ev.data)); } catch(e){}
    };
  } catch (err) {
    bc = null;
  }

  window.syncManager = {
    broadcast(msg) {
      const payload = Object.assign({ ts: Date.now() }, msg);
      if (bc) {
        try { bc.postMessage(payload); } catch (e) { /* ignore */ }
      }
      try {
        localStorage.setItem('ring0_sync_msg', JSON.stringify(payload));
        // keep a short lived key to trigger storage events
        setTimeout(() => localStorage.removeItem('ring0_sync_msg'), 200);
      } catch (e) {}
    },
    onMessage(fn) { listeners.add(fn); return () => listeners.delete(fn); }
  };

  window.addEventListener('storage', (ev) => {
    if (ev.key === 'ring0_sync_msg' && ev.newValue) {
      try { const data = JSON.parse(ev.newValue); listeners.forEach(fn => fn(data)); } catch(e){}
    }
  });
})();





js/ui.js

// Minimal UI helpers to render posts and create safe DOM elements
(function () {
  function createPostElement(post) {
    const card = document.createElement('div');
    card.className = 'image-card';

    const img = document.createElement('img');
    img.loading = 'lazy';
    img.alt = post.title || 'image';
    img.src = post.image_url || '';
    card.appendChild(img);

    const h4 = document.createElement('h4');
    h4.textContent = post.title || 'Untitled';
    card.appendChild(h4);

    const p = document.createElement('p');
    p.textContent = post.description || '';
    card.appendChild(p);

    const actions = document.createElement('div');
    actions.className = 'image-card-actions';

    const del = document.createElement('button');
    del.className = 'image-card-btn delete';
    del.textContent = 'Delete';
    del.addEventListener('click', async () => {
      if (!post.id) return;
      try {
        await window.supabaseHelper.deletePost(post.id);
      } catch (e) {
        console.error(e);
      }
    });

    actions.appendChild(del);
    card.appendChild(actions);

    return card;
  }

  async function renderPosts(container, posts) {
    if (!container) return;
    container.innerHTML = '';
    for (const p of posts) {
      try {
        const el = createPostElement(p);
        container.appendChild(el);
      } catch (e) { console.warn('Error rendering post', e); }
    }
  }

  window.UI = { createPostElement, renderPosts };
})();





sync-Manager.js


/**
 * Universal Sync Manager for RING-0 Lost & Found System
 * Hybrid synchronization approach with multiple fallback mechanisms
 * Designed to achieve 99.9% reliability and <500ms latency
 */

class PropertySyncManager {
    constructor() {
        // Configuration
        this.SYNC_CHANNEL = 'ring0-property-sync';
        this.STORAGE_KEY = 'ring0_properties';
        this.LAST_UPDATE_KEY = 'ring0_last_update';
        this.ADMIN_ONLINE_KEY = 'ring0_admin_online';
        this.SYNC_STATUS_KEY = 'ring0_sync_status';
        this.OFFLINE_QUEUE_KEY = 'ring0_offline_queue';
        this.POLLING_INTERVAL = 5000; // 5 seconds max polling interval
        this.MAX_RETRIES = 5;
        this.RETRY_BASE_DELAY = 100; // ms

        // State
        this.broadcastChannel = null;
        this.isPrimarySync = false;
        this.isAdminPanel = false;
        this.syncStatus = 'initializing';
        this.pendingChanges = new Map();
        this.offlineQueue = [];
        this.retryCount = 0;
        this.pollingIntervalId = null;
        this.lastKnownUpdate = 0;
        this.syncMetrics = {
            successfulSyncs: 0,
            failedSyncs: 0,
            lastSyncTime: 0,
            lastSyncDuration: 0,
            consecutiveFailures: 0
        };

        // Initialize
        this.init();
    }

    /**
     * Initialize the sync manager
     */
    init() {
        // Detect if this is admin panel
        this.isAdminPanel = window.location.pathname.includes('lost_properties.html');

        // Set up sync status monitoring
        this.updateSyncStatus('initializing');

        // Try to establish primary sync (BroadcastChannel)
        this.setupBroadcastChannel();

        // Set up storage event listeners
        this.setupStorageListeners();

        // Set up custom event listeners for same-tab
        this.setupCustomEvents();

        // Load initial data
        this.loadInitialData();

        // Set up periodic sync
        this.setupPeriodicSync();

        // Set up offline queue processing
        this.setupOfflineQueue();

        // Set up visibility change listener
        this.setupVisibilityListener();

        // Set up beforeunload handler
        this.setupBeforeUnload();

        // Check for admin online status
        if (!this.isAdminPanel) {
            this.checkAdminOnlineStatus();
        }

        // Log initialization
        this.logSyncEvent('SyncManager initialized', 'info');
        this.updateSyncStatus('ready');
    }

    /**
     * Set up BroadcastChannel for primary real-time sync
     */
    setupBroadcastChannel() {
        try {
            // Check if BroadcastChannel is supported
            if (typeof BroadcastChannel === 'undefined') {
                this.logSyncEvent('BroadcastChannel not supported', 'warn');
                return;
            }

            // Create channel
            this.broadcastChannel = new BroadcastChannel(this.SYNC_CHANNEL);

            // Handle messages
            this.broadcastChannel.onmessage = (event) => {
                this.handleBroadcastMessage(event.data);
            };

            // Handle errors
            this.broadcastChannel.onerror = (error) => {
                this.logSyncEvent(`BroadcastChannel error: ${error.message}`, 'error');
                this.updateSyncStatus('degraded');
            };

            this.isPrimarySync = true;
            this.logSyncEvent('BroadcastChannel established', 'success');
            this.updateSyncStatus('optimal');

        } catch (error) {
            this.logSyncEvent(`BroadcastChannel setup failed: ${error.message}`, 'error');
            this.isPrimarySync = false;
        }
    }

    /**
     * Handle incoming broadcast messages
     */
    handleBroadcastMessage(message) {
        try {
            const startTime = performance.now();

            // Log the message for debugging
            this.logSyncEvent(`Received broadcast: ${message.type}`, 'debug');

            switch (message.type) {
                case 'data_update':
                    this.handleDataUpdate(message.data, message.timestamp, message.source);
                    break;

                case 'sync_request':
                    this.handleSyncRequest(message.source);
                    break;

                case 'sync_response':
                    this.handleSyncResponse(message.data, message.timestamp);
                    break;

                case 'conflict_resolution':
                    this.handleConflictResolution(message.propertyId, message.resolution);
                    break;

                case 'admin_online':
                    this.handleAdminOnline(message.timestamp);
                    break;

                case 'admin_offline':
                    this.handleAdminOffline();
                    break;

                case 'ping':
                    this.handlePing(message.source);
                    break;

                case 'pong':
                    this.handlePong(message.source);
                    break;

                default:
                    this.logSyncEvent(`Unknown message type: ${message.type}`, 'warn');
            }

            // Update metrics
            this.syncMetrics.lastSyncDuration = performance.now() - startTime;
            this.syncMetrics.lastSyncTime = Date.now();
            this.syncMetrics.successfulSyncs++;

            // Reset consecutive failures on success
            this.syncMetrics.consecutiveFailures = 0;

        } catch (error) {
            this.logSyncEvent(`Error handling broadcast: ${error.message}`, 'error');
            this.syncMetrics.failedSyncs++;
            this.syncMetrics.consecutiveFailures++;

            // Trigger fallback if too many consecutive failures
            if (this.syncMetrics.consecutiveFailures >= 3) {
                this.updateSyncStatus('degraded');
                this.triggerFallbackSync();
            }
        }
    }

    /**
     * Handle data update messages
     */
    handleDataUpdate(data, timestamp, source) {
        // Validate timestamp
        if (timestamp <= this.lastKnownUpdate) {
            this.logSyncEvent('Received outdated update, ignoring', 'debug');
            return;
        }

        // Store the update
        this.lastKnownUpdate = timestamp;

        // Apply the update
        try {
            const currentData = this.getCurrentData();
            const mergedData = this.mergeData(currentData, data);

            // Save merged data
            this.saveData(mergedData);

            // Notify listeners
            this.notifyDataChanged(mergedData);

            // Update timestamp
            localStorage.setItem(this.LAST_UPDATE_KEY, timestamp.toString());

            // If this is admin panel, send acknowledgment
            if (this.isAdminPanel) {
                this.sendBroadcast({
                    type: 'sync_response',
                    data: mergedData,
                    timestamp: Date.now()
                });
            }

        } catch (error) {
            this.logSyncEvent(`Data merge failed: ${error.message}`, 'error');
            this.handleConflict(data, timestamp, source);
        }
    }

    /**
     * Handle sync requests
     */
    handleSyncRequest(source) {
        // Only admin panel should respond to sync requests
        if (!this.isAdminPanel) return;

        try {
            const currentData = this.getCurrentData();
            this.sendBroadcast({
                type: 'sync_response',
                data: currentData,
                timestamp: Date.now(),
                source: 'admin'
            });

        } catch (error) {
            this.logSyncEvent(`Sync request failed: ${error.message}`, 'error');
        }
    }

    /**
     * Handle sync responses
     */
    handleSyncResponse(data, timestamp) {
        // Only non-admin should process sync responses
        if (this.isAdminPanel) return;

        this.handleDataUpdate(data, timestamp, 'admin');
    }

    /**
     * Handle conflict resolution messages
     */
    handleConflictResolution(propertyId, resolution) {
        try {
            const currentData = this.getCurrentData();
            const propertyIndex = currentData.findIndex(p => p.id === propertyId);

            if (propertyIndex !== -1) {
                // Apply resolution
                currentData[propertyIndex] = resolution;

                // Save resolved data
                this.saveData(currentData);

                // Notify listeners
                this.notifyDataChanged(currentData);

                this.logSyncEvent(`Conflict resolved for property ${propertyId}`, 'success');
            }

        } catch (error) {
            this.logSyncEvent(`Conflict resolution failed: ${error.message}`, 'error');
        }
    }

    /**
     * Handle admin online status
     */
    handleAdminOnline(timestamp) {
        if (this.isAdminPanel) return;

        this.logSyncEvent('Admin panel detected online', 'info');

        // Request immediate sync
        this.requestSync();
    }

    /**
     * Handle admin offline status
     */
    handleAdminOffline() {
        if (this.isAdminPanel) return;

        this.logSyncEvent('Admin panel went offline', 'warn');
        this.updateSyncStatus('admin_offline');
    }

    /**
     * Handle ping messages
     */
    handlePing(source) {
        this.sendBroadcast({
            type: 'pong',
            source: this.isAdminPanel ? 'admin' : 'user'
        });
    }

    /**
     * Handle pong messages
     */
    handlePong(source) {
        // Update connectivity status
        this.updateSyncStatus('connected');
    }

    /**
     * Set up storage event listeners
     */
    setupStorageListeners() {
        window.addEventListener('storage', (event) => {
            this.handleStorageEvent(event);
        });
    }

    /**
     * Handle storage events (localStorage changes from other tabs)
     */
    handleStorageEvent(event) {
        try {
            // Ignore our own changes
            if (event.key === this.LAST_UPDATE_KEY && event.newValue) {
                const newTimestamp = parseInt(event.newValue);
                if (newTimestamp > this.lastKnownUpdate) {
                    this.logSyncEvent('Storage event detected, requesting sync', 'debug');
                    this.requestSync();
                }
            }

            // Handle admin online status changes
            if (event.key === this.ADMIN_ONLINE_KEY) {
                if (event.newValue) {
                    this.handleAdminOnline(parseInt(event.newValue));
                } else {
                    this.handleAdminOffline();
                }
            }

        } catch (error) {
            this.logSyncEvent(`Storage event error: ${error.message}`, 'error');
        }
    }

    /**
     * Set up custom events for same-tab communication
     */
    setupCustomEvents() {
        window.addEventListener('propertiesUpdated', () => {
            this.logSyncEvent('Custom event: propertiesUpdated', 'debug');
            this.requestSync();
        });
    }

    /**
     * Load initial data from storage
     */
    loadInitialData() {
        try {
            const storedData = localStorage.getItem(this.STORAGE_KEY);
            if (storedData) {
                const data = JSON.parse(storedData);
                this.lastKnownUpdate = parseInt(localStorage.getItem(this.LAST_UPDATE_KEY) || '0');
                this.logSyncEvent(`Loaded ${data.length} properties`, 'info');
            }

            // Load offline queue
            this.loadOfflineQueue();

        } catch (error) {
            this.logSyncEvent(`Initial data load failed: ${error.message}`, 'error');
        }
    }

    /**
     * Set up periodic sync
     */
    setupPeriodicSync() {
        // Clear any existing interval
        if (this.pollingIntervalId) {
            clearInterval(this.pollingIntervalId);
        }

        // Start with adaptive polling
        this.pollingIntervalId = setInterval(() => {
            this.periodicSyncCheck();
        }, this.getAdaptivePollingInterval());
    }

    /**
     * Get adaptive polling interval based on sync health
     */
    getAdaptivePollingInterval() {
        // If primary sync is working well, use longer intervals
        if (this.isPrimarySync && this.syncMetrics.consecutiveFailures === 0) {
            return Math.min(10000, this.POLLING_INTERVAL * 2); // Max 10 seconds
        }

        // If we're having issues, poll more frequently
        if (this.syncMetrics.consecutiveFailures > 0) {
            return Math.max(1000, this.POLLING_INTERVAL / 2); // Min 1 second
        }

        // Normal interval
        return this.POLLING_INTERVAL;
    }

    /**
     * Periodic sync check
     */
    periodicSyncCheck() {
        try {
            // Check if we should adjust polling interval
            const currentInterval = this.getAdaptivePollingInterval();
            if (this.pollingIntervalId) {
                clearInterval(this.pollingIntervalId);
                this.pollingIntervalId = setInterval(() => {
                    this.periodicSyncCheck();
                }, currentInterval);
            }

            // Check for updates
            const lastUpdate = parseInt(localStorage.getItem(this.LAST_UPDATE_KEY) || '0');
            if (lastUpdate > this.lastKnownUpdate) {
                this.logSyncEvent('Periodic check detected update', 'debug');
                this.requestSync();
            }

            // Send heartbeat if admin
            if (this.isAdminPanel) {
                this.sendAdminHeartbeat();
            }

        } catch (error) {
            this.logSyncEvent(`Periodic sync error: ${error.message}`, 'error');
        }
    }

    /**
     * Send admin heartbeat
     */
    sendAdminHeartbeat() {
        try {
            localStorage.setItem(this.ADMIN_ONLINE_KEY, Date.now().toString());

            // Also send via broadcast if available
            if (this.broadcastChannel) {
                this.sendBroadcast({
                    type: 'admin_online',
                    timestamp: Date.now()
                });
            }

        } catch (error) {
            this.logSyncEvent(`Heartbeat failed: ${error.message}`, 'error');
        }
    }

    /**
     * Set up offline queue processing
     */
    setupOfflineQueue() {
        // Check if we're online
        if (navigator.onLine) {
            this.processOfflineQueue();
        }

        // Listen for online events
        window.addEventListener('online', () => {
            this.logSyncEvent('Network connection restored', 'success');
            this.processOfflineQueue();
        });

        // Listen for offline events
        window.addEventListener('offline', () => {
            this.logSyncEvent('Network connection lost', 'warn');
            this.updateSyncStatus('offline');
        });
    }

    /**
     * Load offline queue from storage
     */
    loadOfflineQueue() {
        try {
            const queueData = localStorage.getItem(this.OFFLINE_QUEUE_KEY);
            if (queueData) {
                this.offlineQueue = JSON.parse(queueData);
                this.logSyncEvent(`Loaded ${this.offlineQueue.length} queued changes`, 'info');
            }

        } catch (error) {
            this.logSyncEvent(`Offline queue load failed: ${error.message}`, 'error');
        }
    }

    /**
     * Save offline queue to storage
     */
    saveOfflineQueue() {
        try {
            localStorage.setItem(this.OFFLINE_QUEUE_KEY, JSON.stringify(this.offlineQueue));
        } catch (error) {
            this.logSyncEvent(`Offline queue save failed: ${error.message}`, 'error');
        }
    }

    /**
     * Process offline queue
     */
    processOfflineQueue() {
        if (!navigator.onLine) {
            this.logSyncEvent('Cannot process queue - still offline', 'debug');
            return;
        }

        if (this.offlineQueue.length === 0) {
            this.logSyncEvent('No queued changes to process', 'debug');
            return;
        }

        this.logSyncEvent(`Processing ${this.offlineQueue.length} queued changes`, 'info');

        // Process each queued change
        const processedChanges = [];
        this.offlineQueue.forEach((change, index) => {
            try {
                // Apply the change
                const currentData = this.getCurrentData();
                const updatedData = this.applyChange(currentData, change);

                // Save the change
                this.saveData(updatedData);

                // Notify listeners
                this.notifyDataChanged(updatedData);

                // Mark as processed
                processedChanges.push(index);

                this.logSyncEvent(`Processed queued change ${index}`, 'success');

            } catch (error) {
                this.logSyncEvent(`Failed to process queued change ${index}: ${error.message}`, 'error');
            }
        });

        // Remove processed changes from queue
        this.offlineQueue = this.offlineQueue.filter((_, index) => !processedChanges.includes(index));
        this.saveOfflineQueue();

        // Request full sync after processing queue
        this.requestSync();
    }

    /**
     * Apply a change to data
     */
    applyChange(currentData, change) {
        switch (change.type) {
            case 'add':
                // Find max ID and increment
                const maxId = currentData.reduce((max, p) => p.id > max ? p.id : max, 0);
                change.data.id = maxId + 1;
                currentData.push(change.data);
                break;

            case 'update':
                const updateIndex = currentData.findIndex(p => p.id === change.data.id);
                if (updateIndex !== -1) {
                    currentData[updateIndex] = change.data;
                }
                break;

            case 'delete':
                const deleteIndex = currentData.findIndex(p => p.id === change.data.id);
                if (deleteIndex !== -1) {
                    currentData.splice(deleteIndex, 1);
                }
                break;

            default:
                this.logSyncEvent(`Unknown change type: ${change.type}`, 'warn');
        }

        return currentData;
    }

    /**
     * Set up visibility change listener
     */
    setupVisibilityListener() {
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                this.logSyncEvent('Page became visible, requesting sync', 'debug');
                this.requestSync();
            }
        });
    }

    /**
     * Set up beforeunload handler
     */
    setupBeforeUnload() {
        window.addEventListener('beforeunload', () => {
            // Save any pending changes to offline queue
            if (this.pendingChanges.size > 0) {
                this.logSyncEvent('Saving pending changes before unload', 'info');

                this.pendingChanges.forEach((change, id) => {
                    this.offlineQueue.push(change);
                });

                this.saveOfflineQueue();
            }
        });
    }

    /**
     * Check admin online status
     */
    checkAdminOnlineStatus() {
        if (this.isAdminPanel) return;

        try {
            const lastAdminOnline = localStorage.getItem(this.ADMIN_ONLINE_KEY);
            if (lastAdminOnline) {
                const lastOnlineTime = parseInt(lastAdminOnline);
                const timeSinceOnline = Date.now() - lastOnlineTime;

                // If admin was online in the last 10 seconds, consider them online
                if (timeSinceOnline < 10000) {
                    this.handleAdminOnline(lastOnlineTime);
                }
            }

        } catch (error) {
            this.logSyncEvent(`Admin status check failed: ${error.message}`, 'error');
        }
    }

    /**
     * Request sync from admin
     */
    requestSync() {
        try {
            // If we have primary sync, use it
            if (this.broadcastChannel) {
                this.sendBroadcast({
                    type: 'sync_request',
                    timestamp: Date.now(),
                    source: this.isAdminPanel ? 'admin' : 'user'
                });
                return;
            }

            // Fallback to storage-based sync request
            this.fallbackSyncRequest();

        } catch (error) {
            this.logSyncEvent(`Sync request failed: ${error.message}`, 'error');
            this.triggerFallbackSync();
        }
    }

    /**
     * Fallback sync request using storage events
     */
    fallbackSyncRequest() {
        try {
            // Use a special key to trigger sync
            const syncRequestKey = 'ring0_sync_request_' + Date.now();
            localStorage.setItem(syncRequestKey, Date.now().toString());

            // Remove it immediately to avoid clutter
            setTimeout(() => {
                localStorage.removeItem(syncRequestKey);
            }, 100);

            // Also try to force a storage event by updating last update time
            localStorage.setItem(this.LAST_UPDATE_KEY, Date.now().toString());

        } catch (error) {
            this.logSyncEvent(`Fallback sync request failed: ${error.message}`, 'error');
        }
    }

    /**
     * Trigger fallback sync mechanisms
     */
    triggerFallbackSync() {
        this.logSyncEvent('Triggering fallback sync mechanisms', 'warn');

        // 1. Try storage-based sync
        this.fallbackSyncRequest();

        // 2. Try polling-based sync
        this.forcePollingSync();

        // 3. Update status
        this.updateSyncStatus('degraded');
    }

    /**
     * Force immediate polling sync
     */
    forcePollingSync() {
        try {
            const lastUpdate = parseInt(localStorage.getItem(this.LAST_UPDATE_KEY) || '0');
            if (lastUpdate > this.lastKnownUpdate) {
                this.logSyncEvent('Forced polling sync detected update', 'debug');
                this.loadAndSyncData();
            }

        } catch (error) {
            this.logSyncEvent(`Forced polling sync failed: ${error.message}`, 'error');
        }
    }

    /**
     * Load and sync data
     */
    loadAndSyncData() {
        try {
            const storedData = localStorage.getItem(this.STORAGE_KEY);
            if (storedData) {
                const data = JSON.parse(storedData);
                const lastUpdate = parseInt(localStorage.getItem(this.LAST_UPDATE_KEY) || '0');

                if (lastUpdate > this.lastKnownUpdate) {
                    this.lastKnownUpdate = lastUpdate;
                    this.notifyDataChanged(data);
                    this.logSyncEvent('Data synced via polling', 'success');
                }
            }

        } catch (error) {
            this.logSyncEvent(`Data sync failed: ${error.message}`, 'error');
        }
    }

    /**
     * Update property data
     */
    update(data) {
        return new Promise((resolve, reject) => {
            try {
                // Validate data
                if (!data || !Array.isArray(data)) {
                    throw new Error('Invalid data format');
                }

                // Check if we're online
                if (!navigator.onLine) {
                    this.logSyncEvent('Offline - queuing change', 'warn');

                    // Queue the change
                    this.offlineQueue.push({
                        type: 'update',
                        data: data,
                        timestamp: Date.now()
                    });

                    this.saveOfflineQueue();
                    return resolve({ success: false, queued: true });
                }

                // Get current data
                const currentData = this.getCurrentData();

                // Merge data with conflict resolution
                const mergedData = this.mergeData(currentData, data);

                // Save merged data
                this.saveData(mergedData);

                // Broadcast the change
                this.broadcastChange(mergedData);

                // Notify listeners
                this.notifyDataChanged(mergedData);

                resolve({ success: true, data: mergedData });

            } catch (error) {
                this.logSyncEvent(`Update failed: ${error.message}`, 'error');
                reject(error);
            }
        });
    }

    /**
     * Add new property
     */
    add(property) {
        return new Promise((resolve, reject) => {
            try {
                // Validate property
                if (!property || typeof property !== 'object') {
                    throw new Error('Invalid property data');
                }

                // Check if we're online
                if (!navigator.onLine) {
                    this.logSyncEvent('Offline - queuing new property', 'warn');

                    // Queue the change
                    this.offlineQueue.push({
                        type: 'add',
                        data: property,
                        timestamp: Date.now()
                    });

                    this.saveOfflineQueue();
                    return resolve({ success: false, queued: true });
                }

                // Get current data
                const currentData = this.getCurrentData();

                // Add the property
                const maxId = currentData.reduce((max, p) => p.id > max ? p.id : max, 0);
                property.id = maxId + 1;
                currentData.push(property);

                // Save data
                this.saveData(currentData);

                // Broadcast the change
                this.broadcastChange(currentData);

                // Notify listeners
                this.notifyDataChanged(currentData);

                resolve({ success: true, property: property });

            } catch (error) {
                this.logSyncEvent(`Add failed: ${error.message}`, 'error');
                reject(error);
            }
        });
    }

    /**
     * Delete property
     */
    delete(propertyId) {
        return new Promise((resolve, reject) => {
            try {
                // Check if we're online
                if (!navigator.onLine) {
                    this.logSyncEvent('Offline - queuing deletion', 'warn');

                    // Queue the change
                    this.offlineQueue.push({
                        type: 'delete',
                        data: { id: propertyId },
                        timestamp: Date.now()
                    });

                    this.saveOfflineQueue();
                    return resolve({ success: false, queued: true });
                }

                // Get current data
                const currentData = this.getCurrentData();

                // Find and remove property
                const index = currentData.findIndex(p => p.id === propertyId);
                if (index === -1) {
                    throw new Error('Property not found');
                }

                const deletedProperty = currentData[index];
                currentData.splice(index, 1);

                // Save data
                this.saveData(currentData);

                // Broadcast the change
                this.broadcastChange(currentData);

                // Notify listeners
                this.notifyDataChanged(currentData);

                resolve({ success: true, property: deletedProperty });

            } catch (error) {
                this.logSyncEvent(`Delete failed: ${error.message}`, 'error');
                reject(error);
            }
        });
    }

    /**
     * Get current data
     */
    getCurrentData() {
        try {
            const storedData = localStorage.getItem(this.STORAGE_KEY);
            return storedData ? JSON.parse(storedData) : [];

        } catch (error) {
            this.logSyncEvent(`Get data failed: ${error.message}`, 'error');
            return [];
        }
    }

    /**
     * Save data to storage
     */
    saveData(data) {
        try {
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
            localStorage.setItem(this.LAST_UPDATE_KEY, Date.now().toString());

            // Update last known update
            this.lastKnownUpdate = Date.now();

            this.logSyncEvent(`Saved ${data.length} properties`, 'debug');

        } catch (error) {
            this.logSyncEvent(`Save data failed: ${error.message}`, 'error');
            throw error;
        }
    }

    /**
     * Merge data with conflict resolution
     */
    mergeData(currentData, newData) {
        try {
            // Create a map of current data for easy lookup
            const currentMap = new Map(currentData.map(p => [p.id, p]));

            // Process each item in new data
            newData.forEach(newProperty => {
                if (currentMap.has(newProperty.id)) {
                    // Existing property - resolve conflicts
                    const currentProperty = currentMap.get(newProperty.id);
                    const resolvedProperty = this.resolveConflict(currentProperty, newProperty);
                    currentMap.set(newProperty.id, resolvedProperty);
                } else {
                    // New property - add it
                    currentMap.set(newProperty.id, newProperty);
                }
            });

            // Convert back to array
            const mergedData = Array.from(currentMap.values());

            // Sort by ID to maintain consistent order
            mergedData.sort((a, b) => a.id - b.id);

            return mergedData;

        } catch (error) {
            this.logSyncEvent(`Merge conflict: ${error.message}`, 'error');
            throw error;
        }
    }

    /**
     * Resolve conflicts between two versions of the same property
     */
    resolveConflict(currentProperty, newProperty) {
        // Conflict resolution strategy:
        // 1. Admin changes always win over user changes
        // 2. For deletions, admin deletions win
        // 3. For other conflicts, use last-write-wins with metadata

        // Check if one version is deleted (doesn't exist in the other dataset)
        const currentExists = currentProperty && currentProperty.id;
        const newExists = newProperty && newProperty.id;

        // If current doesn't exist but new does, it's an addition (not a conflict)
        if (!currentExists && newExists) {
            return newProperty;
        }

        // If new doesn't exist but current does, it's a deletion
        if (currentExists && !newExists) {
            return null; // Mark for deletion
        }

        // Both exist - compare timestamps and sources
        const currentTimestamp = currentProperty.lastUpdated || 0;
        const newTimestamp = newProperty.lastUpdated || 0;

        // Add metadata if missing
        if (!currentProperty.lastUpdated) {
            currentProperty.lastUpdated = Date.now();
            currentProperty.updatedBy = this.isAdminPanel ? 'admin' : 'user';
        }

        if (!newProperty.lastUpdated) {
            newProperty.lastUpdated = Date.now();
            newProperty.updatedBy = this.isAdminPanel ? 'admin' : 'user';
        }

        // Conflict resolution rules:
        // 1. Admin changes always win
        if (newProperty.updatedBy === 'admin' && currentProperty.updatedBy !== 'admin') {
            this.logSyncEvent(`Conflict resolved: admin change wins (property ${newProperty.id})`, 'debug');
            return newProperty;
        }

        // 2. Newer changes win (last-write-wins)
        if (newTimestamp > currentTimestamp) {
            this.logSyncEvent(`Conflict resolved: newer change wins (property ${newProperty.id})`, 'debug');
            return newProperty;
        }

        // 3. If timestamps are equal, prefer the one with more complete data
        if (newTimestamp === currentTimestamp) {
            const resolved = this.mergePropertyData(currentProperty, newProperty);
            this.logSyncEvent(`Conflict resolved: merged data (property ${newProperty.id})`, 'debug');
            return resolved;
        }

        // 4. Default to current version
        this.logSyncEvent(`Conflict resolved: keeping current version (property ${newProperty.id})`, 'debug');
        return currentProperty;
    }

    /**
     * Merge property data intelligently
     */
    mergePropertyData(property1, property2) {
        // Create a new object to avoid mutation
        const merged = { ...property1 };

        // Merge all fields, preferring non-empty values
        const fieldsToMerge = ['name', 'regNumber', 'description', 'location', 'type', 'finderContact',
                              'claimantName', 'claimantContact', 'claimProof', 'image'];

        fieldsToMerge.forEach(field => {
            if (property2[field] && (!merged[field] || merged[field] === 'N/A')) {
                merged[field] = property2[field];
            }
        });

        // For status, prefer claimed over unclaimed
        if (property2.status === 'claimed') {
            merged.status = 'claimed';
        }

        // Update metadata
        merged.lastUpdated = Date.now();
        merged.updatedBy = 'merged';

        return merged;
    }

    /**
     * Broadcast changes to other tabs
     */
    broadcastChange(data) {
        try {
            if (this.broadcastChannel) {
                this.sendBroadcast({
                    type: 'data_update',
                    data: data,
                    timestamp: Date.now(),
                    source: this.isAdminPanel ? 'admin' : 'user'
                });
            }

            // Also trigger storage event for fallback
            localStorage.setItem(this.LAST_UPDATE_KEY, Date.now().toString());

        } catch (error) {
            this.logSyncEvent(`Broadcast failed: ${error.message}`, 'error');
        }
    }

    /**
     * Send broadcast message
     */
    sendBroadcast(message) {
        try {
            if (this.broadcastChannel) {
                this.broadcastChannel.postMessage(message);
                this.logSyncEvent(`Broadcast sent: ${message.type}`, 'debug');
            }

        } catch (error) {
            this.logSyncEvent(`Send broadcast failed: ${error.message}`, 'error');
        }
    }

    /**
     * Notify listeners about data changes
     */
    notifyDataChanged(data) {
        try {
            // Dispatch custom event
            window.dispatchEvent(new CustomEvent('propertiesUpdated', {
                detail: { data: data }
            }));

            // Update sync status
            this.updateSyncStatus('synced');

            // Log the change
            this.logSyncEvent(`Data changed, ${data.length} properties`, 'debug');

        } catch (error) {
            this.logSyncEvent(`Notification failed: ${error.message}`, 'error');
        }
    }

    /**
     * Update sync status
     */
    updateSyncStatus(status) {
        this.syncStatus = status;

        try {
            // Store status
            localStorage.setItem(this.SYNC_STATUS_KEY, JSON.stringify({
                status: status,
                timestamp: Date.now(),
                source: this.isAdminPanel ? 'admin' : 'user'
            }));

            // Dispatch status event
            window.dispatchEvent(new CustomEvent('syncStatusChanged', {
                detail: { status: status }
            }));

            this.logSyncEvent(`Sync status: ${status}`, 'info');

        } catch (error) {
            this.logSyncEvent(`Status update failed: ${error.message}`, 'error');
        }
    }

    /**
     * Get current sync status
     */
    getSyncStatus() {
        return this.syncStatus;
    }

    /**
     * Get sync metrics
     */
    getSyncMetrics() {
        return { ...this.syncMetrics };
    }

    /**
     * Log sync events for debugging
     */
    logSyncEvent(message, level = 'info') {
        // Only log in development or if debugging is enabled
        if (typeof console !== 'undefined') {
            const timestamp = new Date().toISOString();
            const logMessage = `[SyncManager] [${level.toUpperCase()}] [${timestamp}] ${message}`;

            switch (level) {
                case 'error':
                    console.error(logMessage);
                    break;
                case 'warn':
                    console.warn(logMessage);
                    break;
                case 'debug':
                    // Only log debug in development
                    if (process.env.NODE_ENV === 'development') {
                        console.debug(logMessage);
                    }
                    break;
                default:
                    console.log(logMessage);
            }
        }

        // Also dispatch log event for external monitoring
        try {
            window.dispatchEvent(new CustomEvent('syncLog', {
                detail: { message, level, timestamp: Date.now() }
            }));
        } catch (error) {
            // Silent failure for logging
        }
    }

    /**
     * Handle conflicts that couldn't be auto-resolved
     */
    handleConflict(newData, newTimestamp, source) {
        try {
            // Get current data
            const currentData = this.getCurrentData();

            // Identify conflicts
            const conflicts = this.detectConflicts(currentData, newData);

            if (conflicts.length === 0) {
                // No conflicts, just apply the update
                this.handleDataUpdate(newData, newTimestamp, source);
                return;
            }

            // Log conflicts
            this.logSyncEvent(`Detected ${conflicts.length} conflicts with ${source}`, 'warn');

            // For admin changes, always accept them
            if (source === 'admin') {
                this.logSyncEvent('Resolving conflicts: admin changes win', 'info');
                this.handleDataUpdate(newData, newTimestamp, source);
                return;
            }

            // For user changes, try to merge
            try {
                const mergedData = this.mergeData(currentData, newData);
                this.saveData(mergedData);
                this.notifyDataChanged(mergedData);
                this.logSyncEvent('Conflicts resolved by merging', 'success');

            } catch (mergeError) {
                this.logSyncEvent(`Merge failed: ${mergeError.message}`, 'error');

                // If admin is online, request conflict resolution
                if (this.isAdminOnline()) {
                    this.requestConflictResolution(conflicts, newData);
                } else {
                    // Queue the conflicting changes
                    this.queueConflictingChanges(conflicts, newData);
                }
            }

        } catch (error) {
            this.logSyncEvent(`Conflict handling failed: ${error.message}`, 'error');
        }
    }

    /**
     * Detect conflicts between two datasets
     */
    detectConflicts(currentData, newData) {
        const conflicts = [];

        // Create maps for easy comparison
        const currentMap = new Map(currentData.map(p => [p.id, p]));
        const newMap = new Map(newData.map(p => [p.id, p]));

        // Check each property for conflicts
        const allIds = new Set([...currentMap.keys(), ...newMap.keys()]);

        allIds.forEach(id => {
            const current = currentMap.get(id);
            const updated = newMap.get(id);

            // If one exists and the other doesn't, it's not a conflict (addition/deletion)
            if ((!current && updated) || (current && !updated)) {
                return;
            }

            // Compare the properties
            if (!this.propertiesEqual(current, updated)) {
                conflicts.push({
                    propertyId: id,
                    current: current,
                    updated: updated
                });
            }
        });

        return conflicts;
    }

    /**
     * Check if two properties are equal
     */
    propertiesEqual(prop1, prop2) {
        // Simple comparison for now - could be enhanced
        return JSON.stringify(prop1) === JSON.stringify(prop2);
    }

    /**
     * Check if admin is online
     */
    isAdminOnline() {
        try {
            const lastAdminOnline = localStorage.getItem(this.ADMIN_ONLINE_KEY);
            if (lastAdminOnline) {
                const lastOnlineTime = parseInt(lastAdminOnline);
                const timeSinceOnline = Date.now() - lastOnlineTime;
                return timeSinceOnline < 15000; // 15 seconds threshold
            }
            return false;

        } catch (error) {
            this.logSyncEvent(`Admin online check failed: ${error.message}`, 'error');
            return false;
        }
    }

    /**
     * Request conflict resolution from admin
     */
    requestConflictResolution(conflicts, newData) {
        if (this.isAdminPanel) return;

        try {
            // Send conflict resolution request
            this.sendBroadcast({
                type: 'conflict_resolution_request',
                conflicts: conflicts,
                data: newData,
                timestamp: Date.now(),
                source: 'user'
            });

            this.logSyncEvent(`Conflict resolution requested for ${conflicts.length} properties`, 'info');

        } catch (error) {
            this.logSyncEvent(`Conflict resolution request failed: ${error.message}`, 'error');
        }
    }

    /**
     * Queue conflicting changes for later resolution
     */
    queueConflictingChanges(conflicts, newData) {
        try {
            // Store conflicts in offline queue for later resolution
            conflicts.forEach(conflict => {
                this.offlineQueue.push({
                    type: 'conflict',
                    conflict: conflict,
                    timestamp: Date.now()
                });
            });

            this.saveOfflineQueue();
            this.logSyncEvent(`Queued ${conflicts.length} conflicts for later resolution`, 'warn');

        } catch (error) {
            this.logSyncEvent(`Conflict queuing failed: ${error.message}`, 'error');
        }
    }

    /**
     * Clean up resources
     */
    destroy() {
        try {
            // Close broadcast channel
            if (this.broadcastChannel) {
                this.broadcastChannel.close();
                this.broadcastChannel = null;
            }

            // Clear intervals
            if (this.pollingIntervalId) {
                clearInterval(this.pollingIntervalId);
                this.pollingIntervalId = null;
            }

            // Remove event listeners
            window.removeEventListener('storage', this.handleStorageEvent);
            window.removeEventListener('online', this.processOfflineQueue);
            window.removeEventListener('offline', this.handleOffline);
            window.removeEventListener('visibilitychange', this.handleVisibilityChange);
            window.removeEventListener('beforeunload', this.handleBeforeUnload);

            this.logSyncEvent('SyncManager destroyed', 'info');

        } catch (error) {
            this.logSyncEvent(`Destroy failed: ${error.message}`, 'error');
        }
    }
}

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PropertySyncManager;
}

// Auto-initialize if not in module system
if (typeof window !== 'undefined') {
    // Create global instance
    window.PropertySyncManager = PropertySyncManager;

    // Auto-initialize if not already present
    if (!window.propertySyncManager) {
        window.propertySyncManager = new PropertySyncManager();
    }
}
